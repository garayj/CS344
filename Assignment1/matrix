#!/bin/bash
trap "rm -f *.jgtmp; echo 'CTRL+C received, exiting'; exit 1" INT HUP TERM
############################################################
#                        HELPERS                           #
############################################################
_getDims() {
    # Get dimensions of matrix.
    dims $1 >"dimensions-$$.jgtmp"
    read rows columns <"dimensions-$$.jgtmp"
}

############################################################
#                        METHODS                           #
############################################################
transpose() {
    # Get dimensions of matrix.
    _getDims $1

    # Setup variables
    total=$(($rows * $columns))
    limit=$(($total - $columns))
    outputFile='out.jgtmp'
    # colTmp='colTmp.jgtmp'
    # rowTmp='rowTmp.jgtmp'
    array=()

    # Read each line into an array.
    while read line; do
        for x in $line; do
            array+=($x)
        done
    done <$1

    # Loop over the array doing down each column and appending
    # that value to the output file.

    # This loop keeps track of the column the loop is on.
    for ((i = 0; i < $columns; i++)); do
        # This loop goes down the row within a column.
        for ((n = $i; n < $total; n += $columns)); do
            # This is a check if this is the last column in
            # the row.
            if [ $n -lt $limit ]; then
                # Check if the output file exists.
                if [ -f $outputFile ]; then
                    printf "%d\t" ${array[$n]} >>$outputFile
                else
                    printf "%d\t" ${array[$n]} >$outputFile
                fi
            else
                printf "%d\n" ${array[$n]} >>$outputFile
            fi
        done
    done
    cat $outputFile
}

# Prints out the dimensions of the matrix to the terminal.
dims() {
    fileStats="fileStats-$$.jgtmp"
    # Get row count, word count, and character count of the
    # file and stick it into a test file.
    wc $1 >$fileStats

    # Read the contents of the test file
    read rowCount wordCount rest <$fileStats

    # Calculate the number of columns in the matrix
    columnCount=$(($wordCount / $rowCount))

    # Print it out
    echo $rowCount $columnCount
}

add() {
    # Get dimensions of both matrices.
    dim1=$(dims $1)
    dim2=$(dims $2)

    # Check if the dimensions are the same.
    if [ "$dim1" != "$dim2" ]; then
        echo "error 3: These are different dimensions." 1>&2
        clearTmp
        exit 6
    fi

    # Get the dimensions of the output matrix.
    dims $1 >"dims-$$.jgtmp"
    read row col <"dims-$$.jgtmp"
    outputCol=$col

    # Init arrays.
    f1Arr=()
    f2Arr=()

    # Loop through each file, reading each line and each element
    # in each line and push them into the appropriate array.
    while read lineFirstFile && read lineSecondFile <&3; do
        for x in $lineFirstFile; do
            f1Arr+=("$x")
        done
        for y in $lineSecondFile; do
            f2Arr+=("$y")
        done
    done <$1 3<$2

    # Once in an array, use an index and add them together into a new
    # array.
    answerArray=()
    for ((i = 0; i < ${#f1Arr[@]}; i++)); do
        answerArray+=($((${f1Arr[$i]} + ${f2Arr[$i]})))
    done

    # Format the matrix to the correct dimensions.
    outputFile="out-$$.jgtmp"
    for ((j = 0; j < ${#answerArray[@]}; j++)); do

        # Check if the value is at the end of the row. A value of n-1
        # is at the end of the row where n is the number of columns.
        isEndOfCol=$(($j % $outputCol))
        lastColumn=$(($outputCol - 1))
        if [ $isEndOfCol == $lastColumn ]; then
            printf "%d\n" ${answerArray[$j]} >>$outputFile
        else
            if [ $i == 0 ]; then
                printf "%d\t" ${answerArray[$j]} >$outputFile
            else
                printf "%d\t" ${answerArray[$j]} >>$outputFile
            fi

        fi

    done
    cat $outputFile
}

mean() {
    # # Get dimensions of matrix.
    _getDims $1
    colTmp="colTmp-$$.jgtmp"
    outputFile="out-$$.jgtmp"

    # Loop through the each line looking at a specific index/coluk
    for ((i = 0; i < $columns; i++)); do
        index=$(($i + 1))
        echo $index
        flag=0
        while read line; do
            if [ $flag == 0 ]; then
                echo $line | cut -d $'\t' -f $index >$colTmp
                flag=1
            else
                echo $line | cut -d $'\t' -f $index >>$colTmp

            fi
        done <$1

        cat $colTmp
        # Sum the numbers in the column.
        acc=0
        while read tmpLine; do
            acc="$(($tmpLine + $acc))"
        done <$colTmp

        # Use the formula to calculate mean.
        mean=$((($acc + ($rows / 2 * (($acc > 0) * 2 - 1))) / $rows))

        # Display them in the appropriate row.

        # Check if the output file exists
        if [ -f $outputFile ]; then
            # Check if it's the last column in the row.
            lastColumn=$(($columns - 1))
            if [ $i == $lastColumn ]; then
                printf "%d\n" $mean >>$outputFile
            else
                printf "%d\n" $mean >>$outputFile
            fi
        else
            lastColumn=$(expr $columns - 1)
            if [ $i == $lastColumn ]; then
                printf "%d\n" $mean >$outputFile
            else
                printf "%d\t" $mean >$outputFile
            fi

        fi
    done
    cat $outputFile
}

multiply() {
    # Get dimensions of matrix 1
    _getDims $1
    m1Row=$rows
    m1Col=$columns

    # Get dimensions of matrix 2
    _getDims $2
    m2Row=$rows
    m2Col=$columns

    # Check if it is possible to multiply matrices.
    if [ $m1Col != $m2Row ]; then
        echo "Error! These matrices cannot be multiplied. Incorrect dimensions." 1>&2
        clearTmp
        exit 5
    fi

    # Where we will store the answer for the multiplication.
    outputArray=()

    # Loop through each row in matrix 1 and
    # push all values in the row on to an array.
    while read line; do
        m1RowArray=()
        linearM2=()

        # Init an array where we will accumulate.
        outputRow=()
        for ((i = 0; i < $m2Col; i++)); do
            outputRow+=(0)
        done

        # Get a row from matrix 1
        for x in $line; do
            m1RowArray+=($x)
        done

        # Linearize matrix 2 and get it's length.
        length=0
        while read m2Line; do
            for y in $m2Line; do
                linearM2+=($y)
                length=$(($length + 1))
            done
        done <$2

        m1RowIndex=0
        for ((index = 0; index < ${#linearM2[@]}; index++)); do
            idx=$((index % $m2Col))
            if [ $index != 0 ] && [ $idx == 0 ]; then
                m1RowIndex=$(($m1RowIndex + 1))
            fi

            outputRow[$idx]=$((${outputRow[$idx]} + ${m1RowArray[$m1RowIndex]} * ${linearM2[$index]}))
        done
        outputArray=("${outputArray[@]}" "${outputRow[@]}")

    done <$1
    echo ${outputArray[*]}
    # Loop through and store

}
clearTmp() {
    rm -f *.jgtmp
}

validator() {
    tmp1="asdf$$.jgtmp"
    tmp2="fdsa$$.jgtmp"
    # Check if there are any arguments.
    if [ $# == 0 ]; then

        echo "Error! No command found. Try transpose, add, dims, mean or multiply." 1>&2
        clearTmp
        exit 1

    # If there are arguments, check if it's either add or multiply.
    elif [[ $1 == 'add' || $1 == 'multiply' ]]; then
        # Check if there are any more/less arguments than needed.
        if [ $# != 3 ]; then
            echo "Error! Incorrect number of args provided. Ex: ./matrix [command] [file] [file]" 1>&2
            clearTmp
            exit 2
        # Run function if the files are readable.
        elif [ -r $2 ] && [ -r $3 ]; then
            $@
        # Otherwise error out.
        else
            cat $2
            cat $3
            echo "Error! File(s) not readable." 1>&2
            clearTmp
            exit 3
        fi
    # If there are arguments, check if it's any of the other commands.
    elif [[ $1 == 'dims' || $1 == 'transpose' || $1 == 'dims' || $1 == 'mean' ]]; then
        # Check if there are any more/less arguments than needed.
        if [ $# != 2 ]; then
            echo "Error! Incorrect number of args provided. Ex: ./matrix [command] [file]" 1>&2
            clearTmp
            exit 2
            # Run function if the files are readable.
        elif [ -r "$2" ]; then
            $@
        # Otherwise error out.
        else
            echo "Error! File(s) not readable." 1>&2
            clearTmp
            exit 3
        fi

    # If no recognized command is found, error out.
    else
        echo "Error! Command not recognized. Try transpose, add, dims, mean or multiply." 1>&2
        clearTmp
        exit 4
    fi

}
############################################################
#                       VALIDATION                         #
############################################################

############################################################
#                          MAIN                            #
############################################################
validator $@
clearTmp
exit 0
